/*
 * Copyright (C) 2022 neocotic
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

'use strict';

/* istanbul ignore file */

const _ = require('lodash');
const debug = require('debug')('brander:task');
const path = require('path');

const ContextParser = require('../config/context-parser');
const File = require('../file');
const Size = require('../size');
const TaskContext = require('./task-context');
const TaskType = require('./task-type');

const _buildInputFiles = Symbol('buildInputFiles');
const _buildOutputFile = Symbol('buildOutputFile');
const _createFile = Symbol('createFile');
const _parseOptions = Symbol('parseOptions');

/**
 * Capable of parsing {@link TaskContext} information within a data set extracted from configuration data.
 *
 * It is <b>highly recommended</b> that task-related data is only ever parsed iteratively via
 * {@link TaskContextParser#parseNext} so that they can be run step-by-step to support dependencies (e.g. task 2 may
 * depend on files generated by task 1).
 *
 * @public
 */
class TaskContextParser extends ContextParser {

  /**
   * @inheritdoc
   * @override
   */
  async parseData(data, index) {
    const inputFiles = await this[_buildInputFiles](data);
    const options = this[_parseOptions](data);
    const contexts = [];

    if (inputFiles.length === 0) {
      debug('No input files found for data at index: %d', index);

      return contexts;
    }

    const { config } = this;
    const typeName = _.trim(data.task);
    if (!typeName) {
      throw new Error('"task" configuration is required');
    }

    const type = TaskType.valueOf(typeName);
    const { groupBy } = options;
    const groups = _.groupBy(inputFiles, (file) => {
      switch (typeof groupBy) {
      case 'function':
        return groupBy({ config, file });
      case 'string':
        return config.evaluate(groupBy, { file });
      default:
        return null;
      }
    });

    for (const groupFiles of Object.values(groups)) {
      const outputFile = this[_buildOutputFile](data);
      if (!outputFile && type.outputRequired) {
        throw new Error(`"output" configuration is required for "${type}" tasks`);
      }

      const context = new TaskContext(type, groupFiles, outputFile, options, config);

      contexts.push(context);
    }

    return contexts;
  }

  async [_buildInputFiles](data) {
    const { config } = this;
    const { input } = data;
    if (!input) {
      throw new Error('"input" configuration is required');
    }
    if (!input.files) {
      throw new Error('"input.files" configuration is required');
    }
    if (!(typeof input.files === 'string' || Array.isArray(input.files))) {
      throw new Error(`"input.files" configuration can only be a string or an array: ${input.files} ` +
        `(${typeof input.files})`);
    }

    const dir = config.assetPath(config.evaluate(_.trim(input.dir)));
    const files = _.castArray(input.files);
    const inputFiles = [];

    for (let pattern of files) {
      if (typeof pattern !== 'string') {
        throw new Error(`"input.files" configuration can only contain strings: ${pattern} (${typeof pattern})`);
      }

      pattern = _.trim(pattern);
      if (!pattern) {
        throw new Error('"input.files" configuration cannot contain null or empty patterns');
      }

      const filePaths = await File.findFiles(config.evaluate(pattern), { cwd: dir });

      for (const filePath of filePaths) {
        const dirPath = path.resolve(dir, path.dirname(filePath));
        const fileName = path.basename(filePath);
        const file = this[_createFile](dirPath, fileName, input.format, true);

        inputFiles.push(file);
      }
    }

    return inputFiles;
  }

  [_buildOutputFile](data) {
    const { config } = this;
    const { output } = data;
    if (!output) {
      return null;
    }
    if (output.files != null && typeof output.files !== 'string') {
      throw new Error(`"output.files" configuration can only be a string: ${output.files} (${typeof output.files})`);
    }

    let dirPath = _.trim(output.dir);
    dirPath = dirPath ? config.assetPath(dirPath) : null;

    return this[_createFile](dirPath, output.files, output.format, false);
  }

  [_createFile](dirPath, fileName, format, evaluated) {
    dirPath = _.trim(dirPath) || null;
    fileName = _.trim(fileName) || null;
    format = File.deriveFormat(fileName, format);

    if (!(dirPath || fileName || format)) {
      return null;
    }

    return new File(dirPath, fileName, format, this.config, evaluated);
  }

  [_parseOptions](data) {
    const options = data.options ? _.cloneDeep(data.options) : {};
    if (Array.isArray(options.sizes)) {
      options.sizes = options.sizes.map(Size.parse);
    }

    return options;
  }

}

module.exports = TaskContextParser;
