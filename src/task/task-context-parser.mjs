/*
 * Copyright (C) 2023 neocotic
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* istanbul ignore file */

import Debug from 'debug';
import { castArray, cloneDeep, groupBy, trim } from 'lodash-es';
import path from 'path';

import { ContextParser } from '../config/context-parser.mjs';
import { File } from '../file.mjs';
import { Size } from '../size.mjs';
import { TaskContext } from './task-context.mjs';
import { TaskType } from './task-type.mjs';

const debug = Debug('brander:task');

/**
 * Capable of parsing {@link TaskContext} information within a data set extracted from configuration data.
 *
 * It is <b>highly recommended</b> that task-related data is only ever parsed iteratively via
 * {@link TaskContextParser#parseNext} so that they can be run step-by-step to support dependencies (e.g. task 2 may
 * depend on files generated by task 1).
 *
 * @public
 */
export class TaskContextParser extends ContextParser {

  /**
   * @inheritdoc
   * @override
   */
  async parseData(data, index) {
    const inputFiles = await this.#buildInputFiles(data);
    const options = this.#parseOptions(data);
    const contexts = [];

    if (inputFiles.length === 0) {
      debug('No input files found for data at index: %d', index);

      return contexts;
    }

    const { config } = this;
    const typeName = trim(data.task);
    if (!typeName) {
      throw new Error('"task" configuration is required');
    }

    const type = TaskType.valueOf(typeName);
    const { groupBy: groupByValue } = options;
    const groups = groupBy(inputFiles, (file) => {
      switch (typeof groupByValue) {
      case 'function':
        return groupByValue({ config, file });
      case 'string':
        return config.evaluate(groupByValue, { file });
      default:
        return null;
      }
    });

    for (const groupFiles of Object.values(groups)) {
      const outputFile = this.#buildOutputFile(data);
      if (!outputFile && type.outputRequired) {
        throw new Error(`"output" configuration is required for "${type}" tasks`);
      }

      const context = new TaskContext(type, groupFiles, outputFile, options, config);

      contexts.push(context);
    }

    return contexts;
  }

  /**
   * @param {Object} data
   * @return {Promise<File[]>}
   * @private
   */
  async #buildInputFiles(data) {
    const { config } = this;
    const { input } = data;
    if (!input) {
      throw new Error('"input" configuration is required');
    }
    if (!input.files) {
      throw new Error('"input.files" configuration is required');
    }
    if (!(typeof input.files === 'string' || Array.isArray(input.files))) {
      throw new Error(`"input.files" configuration can only be a string or an array: ${input.files} ` +
        `(${typeof input.files})`);
    }

    const dir = config.assetPath(config.evaluate(trim(input.dir)));
    const files = castArray(input.files);
    const inputFiles = [];

    for (let pattern of files) {
      if (typeof pattern !== 'string') {
        throw new Error(`"input.files" configuration can only contain strings: ${pattern} (${typeof pattern})`);
      }

      pattern = trim(pattern);
      if (!pattern) {
        throw new Error('"input.files" configuration cannot contain null or empty patterns');
      }

      const filePaths = await File.findFiles(config.evaluate(pattern), { cwd: dir });

      for (const filePath of filePaths) {
        const dirPath = path.resolve(dir, path.dirname(filePath));
        const fileName = path.basename(filePath);
        const file = this.#createFile(dirPath, fileName, input.format, true);

        if (file) {
          inputFiles.push(file);
        }
      }
    }

    return inputFiles;
  }

  /**
   * @param {Object} data
   * @return {?File}
   * @private
   */
  #buildOutputFile(data) {
    const { config } = this;
    const { output } = data;
    if (!output) {
      return null;
    }
    if (output.files != null && typeof output.files !== 'string') {
      throw new Error(`"output.files" configuration can only be a string: ${output.files} (${typeof output.files})`);
    }

    let dirPath = trim(output.dir);
    dirPath = dirPath ? config.assetPath(dirPath) : null;

    return this.#createFile(dirPath, output.files, output.format, false);
  }

  /**
   * @param {string} dirPath
   * @param {string} fileName
   * @param {?string} format
   * @param {boolean} evaluated
   * @return {?File}
   * @private
   */
  #createFile(dirPath, fileName, format, evaluated) {
    dirPath = trim(dirPath) || null;
    fileName = trim(fileName) || null;
    format = File.deriveFormat(fileName, format);

    if (!(dirPath || fileName || format)) {
      return null;
    }

    return new File(dirPath, fileName, format, this.config, evaluated);
  }

  /**
   * @param {Object} data
   * @return {Object}
   * @private
   */
  #parseOptions(data) {
    const options = data.options ? cloneDeep(data.options) : {};
    if (Array.isArray(options.sizes)) {
      options.sizes = options.sizes.map(Size.parse);
    }

    return options;
  }

}
